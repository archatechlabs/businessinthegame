'use client'

import { useState, useEffect, useRef, useCallback } from 'react'
import { useAuth } from '@/contexts/AuthContext'

interface AgoraViewerProps {
  channelName: string
  onLeave: () => void
}

export default function AgoraViewer({ channelName, onLeave }: AgoraViewerProps) {
  const { userProfile } = useAuth()
  const [isViewing, setIsViewing] = useState(false)
  const [isConnecting, setIsConnecting] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [viewerCount, setViewerCount] = useState(0)
  const [agoraLoaded, setAgoraLoaded] = useState(false)
  const [connectionState, setConnectionState] = useState<string>('disconnected')
  
  const clientRef = useRef<unknown>(null)
  const videoRef = useRef<HTMLVideoElement>(null)

  // Check Agora App ID availability
  const agoraAppId = process.env.NEXT_PUBLIC_AGORA_APP_ID?.trim()

  // Load Agora SDK
  useEffect(() => {
    const loadAgora = async () => {
      try {
        await import('agora-rtc-sdk-ng')
        console.log('‚úÖ Agora SDK loaded for viewer')
        setAgoraLoaded(true)
      } catch (err) {
        console.error('‚ùå Failed to load Agora SDK:', err)
        setError('Failed to load video streaming SDK')
      }
    }
    
    loadAgora()
  }, [])

  // Generate Agora token for viewer
  const generateToken = useCallback(async (channel: string, uid: number) => {
    try {
      console.log('üé´ Generating Agora token for viewer, channel:', channel, 'UID:', uid)
      const response = await fetch(`/api/agora/token?channel=${channel}&uid=${uid}&role=subscriber`)
      
      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || 'Failed to generate token')
      }
      
      const data = await response.json()
      console.log('‚úÖ Token generated successfully for viewer UID:', uid)
      return data.token
    } catch (err) {
      console.error('‚ùå Error generating token:', err)
      throw err
    }
  }, [])

  // Generate a consistent numeric UID for viewer
  const getNumericUid = useCallback(() => {
    if (userProfile?.uid) {
      // Try to convert string UID to number, fallback to hash
      const numericUid = parseInt(userProfile.uid, 10)
      if (!isNaN(numericUid) && numericUid > 0) {
        return numericUid + 10000 // Add offset to differentiate from streamer
      }
      // If string UID can't be converted to number, create a hash
      let hash = 0
      for (let i = 0; i < userProfile.uid.length; i++) {
        const char = userProfile.uid.charCodeAt(i)
        hash = ((hash << 5) - hash) + char
        hash = hash & hash // Convert to 32-bit integer
      }
      return Math.abs(hash) + 10000
    }
    return Math.floor(Math.random() * 100000) + 10000 // Random UID for anonymous viewers
  }, [userProfile?.uid])

  // Initialize Agora client for viewing
  const initAgoraClient = useCallback(async () => {
    if (clientRef.current) {
      return clientRef.current
    }

    if (!agoraLoaded) {
      throw new Error('Agora SDK not loaded')
    }

    if (!agoraAppId) {
      throw new Error('Agora App ID not configured')
    }

    console.log('üé¨ Initializing Agora client for viewer with App ID:', agoraAppId)
    const AgoraRTCModule = await import('agora-rtc-sdk-ng')
    const client = AgoraRTCModule.default.createClient({
      mode: 'rtc',
      codec: 'vp8'
    })
    
    // Add event listeners
    client.on('connection-state-change', (newState, reason) => {
      console.log('üîó Viewer connection state changed:', newState, reason)
      setConnectionState(newState)
    })

    client.on('user-joined', (user) => {
      console.log('üë§ User joined (viewer sees):', user.uid)
    })

    client.on('user-left', (user) => {
      console.log('üë§ User left (viewer sees):', user.uid)
    })

    client.on('user-published', async (user, mediaType) => {
      console.log('üì∫ User published stream:', user.uid, mediaType)
      try {
        await client.subscribe(user, mediaType)
        console.log('‚úÖ Subscribed to user stream:', user.uid, mediaType)
        
        if (mediaType === 'video' && user.videoTrack && videoRef.current) {
          console.log('üé¨ Playing remote video stream')
          user.videoTrack.play(videoRef.current)
        }
      } catch (err) {
        console.error('‚ùå Error subscribing to user stream:', err)
      }
    })

    client.on('user-unpublished', (user, mediaType) => {
      console.log('üì∫ User unpublished stream:', user.uid, mediaType)
    })
    
    clientRef.current = client
    console.log('‚úÖ Agora client created for viewer')
    return client
  }, [agoraLoaded, agoraAppId])

  // Join channel as viewer
  const joinChannel = useCallback(async (client: unknown) => {
    try {
      console.log('üéØ Joining Agora channel as viewer:', channelName)
      
      // Get consistent numeric UID
      const uid = getNumericUid()
      console.log('üë§ Using viewer UID:', uid)
      
      // Generate token with the same UID
      const token = await generateToken(channelName, uid)
      
      // Type assertion for Agora client methods
      const agoraClient = client as { 
        join: (appId: string, channel: string, token: string | null, uid: string | number | null) => Promise<void>
      }
      
      // Join the channel as viewer
      await agoraClient.join(
        agoraAppId!.trim(),
        channelName,
        token,
        uid
      )
      
      console.log('‚úÖ Joined channel as viewer successfully')
      setIsViewing(true)
      setIsConnecting(false)
      
    } catch (err) {
      console.error('‚ùå Error joining channel as viewer:', err)
      throw err
    }
  }, [channelName, agoraAppId, getNumericUid, generateToken])

  // Initialize viewer
  useEffect(() => {
    const initViewer = async () => {
      try {
        if (!agoraLoaded) return

        setIsConnecting(true)
        setError(null)

        // Initialize Agora client
        const client = await initAgoraClient()
        
        // Join channel
        await joinChannel(client)

      } catch (err) {
        console.error('‚ùå Error initializing viewer:', err)
        if (err instanceof Error) {
          setError(err.message)
        } else {
          setError('Failed to start viewing')
        }
        setIsConnecting(false)
      }
    }

    initViewer()

    return () => {
      cleanup()
    }
  }, [agoraLoaded, initAgoraClient, joinChannel])

  const cleanup = async () => {
    try {
      if (clientRef.current) {
        const client = clientRef.current as { leave: () => Promise<void> }
        await client.leave()
        clientRef.current = null
      }
    } catch (err) {
      console.error('Error during cleanup:', err)
    }
  }

  const stopViewing = async () => {
    try {
      await cleanup()
      setIsViewing(false)
      setViewerCount(0)
      onLeave()
    } catch (err) {
      console.error('Error stopping viewer:', err)
    }
  }

  if (error) {
    return (
      <div className="w-full h-full bg-gray-900 flex items-center justify-center">
        <div className="text-center text-white">
          <div className="text-red-500 mb-4 text-4xl">‚ö†Ô∏è</div>
          <p className="text-lg mb-2">Viewing Error</p>
          <p className="text-sm text-gray-300 mb-4">{error}</p>
          <div className="space-x-2">
            <button
              onClick={() => window.location.reload()}
              className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
            >
              Retry
            </button>
            <button
              onClick={stopViewing}
              className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700"
            >
              Close
            </button>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="w-full h-full bg-gray-900 relative">
      <video
        ref={videoRef}
        autoPlay
        playsInline
        className="w-full h-full object-cover"
        style={{ transform: 'scaleX(-1)' }} // Mirror the video
      />
      
      {isConnecting && (
        <div className="absolute inset-0 flex items-center justify-center bg-gray-900 bg-opacity-75">
          <div className="text-center text-white">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto mb-4"></div>
            <p className="text-lg">Connecting to Stream...</p>
            <p className="text-sm opacity-75">Channel: {channelName}</p>
          </div>
        </div>
      )}

      {!isViewing && !isConnecting && (
        <div className="absolute inset-0 flex items-center justify-center bg-gray-900">
          <div className="text-center text-white">
            <div className="text-gray-400 mb-4 text-4xl">üì∫</div>
            <p className="text-lg mb-2">No Stream Available</p>
            <p className="text-sm text-gray-300">Waiting for streamer to start...</p>
          </div>
        </div>
      )}

      {/* Viewer Controls */}
      <div className="absolute bottom-4 left-4 right-4">
        <div className="flex items-center justify-between bg-black bg-opacity-50 rounded-lg p-3">
          <div className="flex items-center space-x-3">
            <span className="inline-flex items-center px-2 py-1 rounded-full text-xs font-medium bg-red-600 text-white">
              <div className="w-2 h-2 bg-white rounded-full mr-1.5 animate-pulse"></div>
              LIVE
            </span>
            <span className="text-white text-sm">Channel: {channelName}</span>
            <span className="text-white text-sm">Viewers: {viewerCount}</span>
            <span className="text-white text-sm">Status: {connectionState}</span>
          </div>

          <button
            onClick={stopViewing}
            className="bg-gray-600 text-white px-4 py-2 rounded-md hover:bg-gray-700 flex items-center"
          >
            <span className="mr-2">‚ùå</span>
            Leave
          </button>
        </div>
      </div>
    </div>
  )
}
